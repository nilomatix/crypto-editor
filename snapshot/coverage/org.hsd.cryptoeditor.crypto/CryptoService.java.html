<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CryptoService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crypto-editor</a> &gt; <a href="index.source.html" class="el_package">org.hsd.cryptoeditor.crypto</a> &gt; <span class="el_source">CryptoService.java</span></div><h1>CryptoService.java</h1><pre class="source lang-java linenums">package org.hsd.cryptoeditor.crypto;

import org.bouncycastle.jce.X509Principal;
import org.bouncycastle.x509.X509V3CertificateGenerator;
import org.hsd.cryptoeditor.CryptoEditorException;
import org.hsd.cryptoeditor.crypto.encryption.Encryption;
import org.hsd.cryptoeditor.crypto.encryption.EncryptionType;
import org.hsd.cryptoeditor.crypto.grapher.CryptographerException;
import org.hsd.cryptoeditor.crypto.grapher.BCCryptographer;
import org.hsd.cryptoeditor.crypto.grapher.Cryptographer;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.X509Certificate;
import java.security.spec.X509EncodedKeySpec;
import java.util.Arrays;
import java.util.Calendar;

/**
 * Service handling all cryptography-related operations
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public class CryptoService {</span>

    private static final int ITERATIONS = 1024;
    private static final int SEED_BYTES = 32;

    /**
     * Resolves the passed encryption-type to an appropriate encryption object.
     *
     * @param type encryption-type to resolve
     * @return appropriate encryption object
     */
    public Encryption getEncryption(EncryptionType type) {
<span class="fc" id="L38">        return new Encryption(type);</span>
    }

    /**
     * Resolves keys or key-pairs by either generating or retrieving them from storage and assembles a cryptographer initialized with the passed encryption and the key material.
     * &lt;p&gt;
     * &lt;strong&gt;For Encryption with a PBE type:&lt;/strong&gt;
     * For encryptions where {@link EncryptionType#isPBEType()} is &lt;i&gt;true&lt;/i&gt;, the key will be generated from the passed password using the method specified by the encryption type.
     * &lt;p&gt;
     * &lt;strong&gt;For Encryption with a symmetric type:&lt;/strong&gt;
     * For encryptions where {@link EncryptionType#isAsymmetric()} is &lt;i&gt;false&lt;/i&gt;, a key will either be retrieved from local storage or generated.
     * &lt;p&gt;
     * &lt;strong&gt;For Encryption with an asymmetric type:&lt;/strong&gt;
     * For encryptions where {@link EncryptionType#isAsymmetric()} is &lt;i&gt;true&lt;/i&gt;, the public get will be read from the passed encryption via {@link Encryption#getPublicKey()}.
     * If the public key is present, the private key will be retrieved from local storage. Otherwise a new key-pair will be generated.
     *
     * @param encryption encryption object for cryptographic operations
     * @param password   either for PBE key derivation or key retrieval from storage
     * @return assemble cryptographer
     */
    public Cryptographer getCryptographer(Encryption encryption, char[] password) {
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (password == null) {</span>
<span class="nc" id="L60">            throw new IllegalArgumentException(&quot;A password is required&quot;);</span>
        }
<span class="nc" id="L62">        Cryptographer cryptographer = new BCCryptographer();</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (encryption.getType().isAsymmetric()) {</span>
<span class="nc" id="L64">            KeyPair keyPair = getKeyPair(encryption, password);</span>
<span class="nc" id="L65">            cryptographer.setEncryption(encryption);</span>
<span class="nc" id="L66">            cryptographer.setKeyPair(keyPair);</span>
<span class="nc" id="L67">        } else {</span>
<span class="nc" id="L68">            Key key = null;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (encryption.getType().isPBEType()) {</span>
<span class="nc" id="L70">                key = getPBEKey(encryption, password);</span>
            } else {
<span class="nc" id="L72">                key = getSecretKey(encryption, password);</span>
            }
<span class="nc" id="L74">            cryptographer.setEncryption(encryption);</span>
<span class="nc" id="L75">            cryptographer.setKey(key);</span>
        }
<span class="nc" id="L77">        return cryptographer;</span>
    }

    /**
     * Hashes the input with SHA-256 using the Bouncy Castle Provider
     *
     * @param input content to hash
     * @return resulting hash
     */
    public byte[] getHash(byte[] input) {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if(input == null) {</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }
        try {
<span class="fc" id="L91">            MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;, &quot;BC&quot;);</span>
<span class="fc" id="L92">            messageDigest.update(input);</span>
<span class="fc" id="L93">            return messageDigest.digest();</span>
<span class="nc" id="L94">        } catch (Exception e) {</span>
<span class="nc" id="L95">            throw new CryptographerException(e);</span>
        }
    }

    /**
     * Hashes the input with SHA-256 using the Bouncy Castle Provider and matches the result with the passed testHash
     *
     * @param input    content to hash
     * @param testHash hash to test against
     * @return result of the match-test
     */
    public boolean hashMatch(byte[] input, byte[] testHash) {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if(input == null) {</span>
<span class="nc" id="L108">            throw new IllegalArgumentException(&quot;input cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if(testHash == null) {</span>
<span class="nc" id="L111">            throw new IllegalArgumentException(&quot;testHash cannot be null&quot;);</span>
        }
<span class="fc" id="L113">        return Arrays.equals(getHash(input), testHash);</span>
    }

    private Key getSecretKey(Encryption encryption, char[] password) {
<span class="nc bnc" id="L117" title="All 4 branches missed.">        assert !encryption.getType().isAsymmetric() : encryption.getType();</span>

<span class="nc" id="L119">        SecretKey key = StoreService.getInstance().loadSecretKey(encryption.getType().getName(), password);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (key == null) {</span>
            try {
<span class="nc" id="L122">                key = KeyGenerator.getInstance(encryption.getType().getName(), &quot;BC&quot;).generateKey();</span>
<span class="nc" id="L123">                StoreService.getInstance().storeSecretKey(encryption.getType().getName(), key, password);</span>
<span class="nc" id="L124">            } catch (Exception e) {</span>
<span class="nc" id="L125">                throw new CryptoEditorException(</span>
<span class="nc" id="L126">                        String.format(&quot;Could not generate secret-key for algorithm %s&quot;, encryption.getType().getName()), e);</span>
<span class="nc" id="L127">            }</span>
        }
<span class="nc" id="L129">        return key;</span>
    }

    private KeyPair getKeyPair(Encryption encryption, char[] password) {
<span class="nc bnc" id="L133" title="All 4 branches missed.">        assert encryption.getType().isAsymmetric() : encryption.getType();</span>

<span class="nc" id="L135">        byte[] publicKeyBytes = encryption.getPublicKey();</span>
<span class="nc" id="L136">        KeyPair keyPair = null;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (publicKeyBytes != null) {</span>
            // get private key
<span class="nc" id="L139">            PrivateKey privateKey = StoreService.getInstance().loadPrivateKey(encryption.getType().getName(), password);</span>
            try {
<span class="nc" id="L141">                PublicKey publicKey = KeyFactory.getInstance(encryption.getType().getName(), &quot;BC&quot;)</span>
<span class="nc" id="L142">                        .generatePublic(new X509EncodedKeySpec(publicKeyBytes));</span>
<span class="nc" id="L143">                keyPair = new KeyPair(publicKey, privateKey);</span>
<span class="nc" id="L144">            } catch (Exception e) {</span>
<span class="nc" id="L145">                throw new CryptoEditorException(&quot;Could not recover public key from serialization&quot;, e);</span>
<span class="nc" id="L146">            }</span>
<span class="nc" id="L147">        } else {</span>
            // generate key pair
            try {
<span class="nc" id="L150">                keyPair = KeyPairGenerator.getInstance(encryption.getType().getName(), &quot;BC&quot;).generateKeyPair();</span>
                // store private key in key store
<span class="nc" id="L152">                StoreService.getInstance()</span>
<span class="nc" id="L153">                        .storePrivateKey(encryption.getType().getName(), keyPair.getPrivate(), password, generateCertificate(keyPair));</span>
                // expose public key
<span class="nc" id="L155">                encryption.setPublicKey(keyPair.getPublic().getEncoded());</span>
<span class="nc" id="L156">            } catch (Exception e) {</span>
<span class="nc" id="L157">                throw new CryptoEditorException(</span>
<span class="nc" id="L158">                        String.format(&quot;Could not generate key-pair for algorithm %s&quot;, encryption.getType().getName()), e);</span>
<span class="nc" id="L159">            }</span>
        }
<span class="nc" id="L161">        return keyPair;</span>
    }

    private Key getPBEKey(Encryption encryption, char[] password) {
<span class="nc bnc" id="L165" title="All 4 branches missed.">        assert encryption.getType().isPBEType() : encryption.getType();</span>

<span class="nc" id="L167">        Key key = null;</span>
<span class="nc" id="L168">        byte[] salt = encryption.getSalt();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (salt == null) {</span>
<span class="nc" id="L170">            SecureRandom secureRandom = new SecureRandom();</span>
<span class="nc" id="L171">            salt = secureRandom.generateSeed(SEED_BYTES);</span>
<span class="nc" id="L172">            encryption.setSalt(salt);</span>
        }

<span class="nc" id="L175">        PBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, ITERATIONS);</span>
        try {
<span class="nc" id="L177">            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(encryption.getType().getName(), &quot;BC&quot;);</span>
<span class="nc" id="L178">            key = keyFactory.generateSecret(pbeKeySpec);</span>
<span class="nc" id="L179">        } catch (Exception e) {</span>
<span class="nc" id="L180">            throw new CryptoEditorException(</span>
<span class="nc" id="L181">                    String.format(&quot;Could not generate PBE-key for scheme %s&quot;, encryption.getType().getName()), e);</span>
<span class="nc" id="L182">        }</span>
<span class="nc" id="L183">        return key;</span>
    }

    /**
     * Utility method to generate a random certificate for private-key storage in java keystore
     *
     * @param keyPair RSA keypair to generate certificate for
     * @return self-signed utility certificate
     * @see java.security.KeyStore.PrivateKeyEntry
     */
    private X509Certificate generateCertificate(KeyPair keyPair) {
<span class="nc" id="L194">        X509V3CertificateGenerator cert = new X509V3CertificateGenerator();</span>
<span class="nc" id="L195">        cert.setSerialNumber(BigInteger.valueOf(1));</span>
<span class="nc" id="L196">        cert.setSubjectDN(new X509Principal(&quot;CN=localhost&quot;));</span>
<span class="nc" id="L197">        cert.setIssuerDN(new X509Principal(&quot;CN=localhost&quot;));</span>
<span class="nc" id="L198">        cert.setPublicKey(keyPair.getPublic());</span>
<span class="nc" id="L199">        Calendar notBefore = Calendar.getInstance();</span>
<span class="nc" id="L200">        cert.setNotBefore(notBefore.getTime()); // valid from now on</span>
<span class="nc" id="L201">        Calendar notAfter = Calendar.getInstance();</span>
<span class="nc" id="L202">        notAfter.add(Calendar.YEAR, 1);// valid for 1 year</span>
<span class="nc" id="L203">        cert.setNotAfter(notAfter.getTime());</span>
<span class="nc" id="L204">        cert.setSignatureAlgorithm(&quot;SHA1WithRSAEncryption&quot;);</span>
<span class="nc" id="L205">        PrivateKey signingKey = keyPair.getPrivate();</span>
        try {
<span class="nc" id="L207">            return cert.generate(signingKey, &quot;BC&quot;);</span>
<span class="nc" id="L208">        } catch (Exception e) {</span>
<span class="nc" id="L209">            throw new CryptoEditorException(&quot;Could not generate RSA certificate&quot;, e);</span>
        }
    }


    /////

<span class="fc" id="L216">    private static final CryptoService instance = new CryptoService();</span>

<span class="fc" id="L218">    private CryptoService() {</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (instance != null) {</span>
<span class="nc" id="L220">            throw new IllegalStateException(&quot;Already instantiated&quot;);</span>
        }
<span class="fc" id="L222">    }</span>

    public static CryptoService getInstance() {
<span class="fc" id="L225">        return instance;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>